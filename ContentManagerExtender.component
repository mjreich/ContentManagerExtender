<?php
namespace ContentManagerExtender;
/**
 * ContentManagerExtender
 *
 * ContentManagerExtender â€” Wraps the ContentManager in an easy to use event for adding new types.
 *
 * @package    ContentManagerExtender
 * @version    0.1.0
 * @author     Seabourne Consulting
 * @license    MIT License
 * @copyright  2012 Seabourne Consulting
 * @link       https://mjreich@github.com/mjreich/ContentManagerExtender.git
 */

use \Cumula\BaseComponent as BaseComponent;

/**
 * ContentManagerExtender Class
 *
 * The ContentManagerExtender Class provides an easy to use wrapper around the ContentManager API.  The goal is to
 * allow developers to easily add new types without having to create the same bidings for each content type each time.
 * 
 * This component also injects a new set of type specific event into the ContentManager for each newly declared type.  
 * For example, if one declares 'Page' as a type, this Component will add PageItemCreate, PageItemUpdate, etc events to
 * the ContentManager that all components can bind to.  These events will fire before the end of the generic ContentItem* 
 * Event cycle.
 *
 * ### Events
 * The ContentManagerExtender Class defines the following events:
 *
 * #### GatherContentExtensions
 * This event is fired after the boot_startup phase to collect the content type/datastore definitions from listeners.
 * Each listener should return an array of arrays.  Each array should include a 'type' key declaring the content type and a 
 * 'data_store' key referencing a BaseDataStore class used to store the information.
 *
 * **Args**:
 * 
 * None
 *
 * @package		ContentManagerExtender
 * @author     Seabourne Consulting
 */
class ContentManagerExtender extends BaseComponent {
	/**
	 * The internal storage for the gathered content extensions.
	 *
	 * @var array
	 */
	protected $_extensions;
	
	/**
	 * Constructor
	 *
	 * @author Mike Reich
	 */
	public function __construct() {
		parent::__construct();
		$this->addEvent('GatherContentExtensions');
		
		$this->_extensions = array();
	}
	
	/**
	 * Standard BaseComponent startup function.  Adds the dispatcher for the gatherContentExtensions event to the after_boot_startup
	 * phase.
	 *
	 * @return void
	 * @author Mike Reich
	 */
	public function startup() {		
		$this->addEventListenerTo('Application', 'after_boot_startup', 'gatherContentExtensions');
	}
	
	/**
	 * Returns the collected types
	 *
	 * @return void
	 * @author Mike Reich
	 */
	public function getTypes() {
		return array_keys($this->_extensions);
	}
	
	/**
	 * Returns an array of data stores associated with the type.
	 *
	 * @param string $type the type to find by data stores by
	 * @return array|boolean an array of matching data stores, or false if the type is not defined
	 * @author Mike Reich
	 */
	public function getTypeDataStores($type) {
		if(isset($this->_extensions[$type])) {
			return $this->_extensions[$type]);
		} else 
			return false;
	}
	
	/**
	 * Dispatch function for the GatherContentExtensions event.  Processes the gathered extensions, creating events for each type.
	 *
	 * @return void
	 * @author Mike Reich
	 */
	public function gatherContentExtensions() {
		$ext = &$this->_extensions;
		
		//Collect the extensions as returned values for the event.
		$this->dispatch('GatherContentExtensions', array(), function($extensions) use(&$ext) {
			if(is_array($extensions)) {
				foreach($extensions as $key => $config) {
					if(!isset($ext[$config['type']])) {
						$ext[$config['type']] = array();
					}
					$ext[$config['type']][] = $config;
				}
			}
		});
		
		//Sanity check array to ensure we aren't creating duplicate events.
		$exists = array();
		
		//For each event, we bind to the ContentManager event and create a new type specific event.
		//TODO: Bind to the before_ContentItem* event to ensure that the new defined events are fired before the 
		//ContentManager event, rather than in teh middle.
		foreach($this->_extensions as $type => $config) {
			if(!in_array($type, $exists)) {
				$this->addEventListenerTo('ContentManager', 'ContentItemCreate', 'createHandler_'.$type);
				$this->addEventListenerTo('ContentManager', 'ContentItemUpdate', 'updateHandler_'.$type);
				$this->addEventListenerTo('ContentManager', 'ContentItemDelete', 'deleteHandler_'.$type);
				$this->addEventListenerTo('ContentManager', 'ContentItemLoad', 'loadHandler_'.$type);
				$this->addEventListenerTo('ContentManager', 'ContentItemQuery', 'queryHandler_'.$type);
			
				$cm = \I('ContentManager');
				$cm->addEvent($type.'Create');
				$cm->addEvent($type.'Update');
				$cm->addEvent($type.'Load');
				$cm->addEvent($type.'Delete');
				$cm->addEvent($type.'Query');
				$exists[] = $type;
			}
		}
	}

	/**
	 * Magic Method for handling incoming events.
	 *
	 * @param string $name 
	 * @param string $params 
	 * @return void
	 * @author Mike Reich
	 */
	public function __call($name, $params) {
		list($func, $type) = explode('_', $name);
		$r = $this->_extensions[$type];
		$data_stores = array();
		foreach($r as $config) {
			$data_stores[] = $config['data_store'];
		}
		array_push($params, $type);
		array_push($params, $data_stores);
		return call_user_func_array(array(&$this, $func), $params);
	}

	/**
	 * The handler for the incoming create events.  Dispatches the type specific create event
	 *
	 * @param string $event 
	 * @param string $dispatcher 
	 * @param string $content 
	 * @param string $type 
	 * @param string $data_stores 
	 * @return void
	 * @author Mike Reich
	 */
	public function createHandler($event, $dispatcher, $content, $type, $data_stores) {
		if($content->type != $type)
			return;
		$cm = \I('ContentManager');
		$cm->dispatch($type.'Create', array($content), function($new_item) use ($content) {
			$content = object_merge($content, $new_item);
		});	
		foreach($data_stores as $data_store) {
			if($new_content = $data_store->create($content)) {
				$content = object_merge($content, $new_content);
			} else {
				throw new Exception('Could not save content with type '.$type);
			}
		}
		return $content;
	}
	
	/**
	 * Handler for the incoming update events.  Dispatches the type specific item update event.
	 *
	 * @param string $event 
	 * @param string $dispatcher 
	 * @param string $content 
	 * @param string $type 
	 * @param string $data_stores 
	 * @return void
	 * @author Mike Reich
	 */
	public function updateHandler($event, $dispatcher, $content, $type, $data_stores) {
		if($content->type != $type)
			return $content;
		
		$cm = \I('ContentManager');
		$cm->dispatch($type.'Update', array($content), function($new_item) use ($content) {
			$content = object_merge($content, $new_item);
		});	
		foreach($data_stores as $data_store) {
			if($new_content = $data_store->update($content)) {
				$content = object_merge($content, $new_content);
			} else {
				throw new Exception('Could not save content with type '.$type);
			}
		}
		return $content;
	}
	
	/**
	 * Handler for the incoming delete event.  Dispatches the type specific delete event.
	 *
	 * @param string $event 
	 * @param string $dispatcher 
	 * @param string $content 
	 * @param string $type 
	 * @param string $data_stores 
	 * @return void
	 * @author Mike Reich
	 */
	public function deleteHandler($event, $dispatcher, $content, $type, $data_stores) {
		if($content->type != $type)
			return;		
			
		$cm = \I('ContentManager');
		$cm->dispatch($type.'Delete', array($id));
		foreach($data_stores as $data_store) {
			if(!$data_store->destroy(array('uuid' => $content->uuid))) {
				throw new Exception('Could not delete content.');
			}
		}
	}
	
	/**
	 * Handler for the incoming load function.
	 *
	 * @param string $event 
	 * @param string $dispatcher 
	 * @param string $content 
	 * @param string $type 
	 * @param string $data_stores 
	 * @return void
	 * @author Mike Reich
	 */
	public function loadHandler($event, $dispatcher, $content, $type, $data_stores) {
		if($content->type != $type)
			return;		
			
		$cm = \I('ContentManager');
		$cm->dispatch($type.'Load', array(&$content), function($new_item) use (&$content) {
			if(is_array($new_item) || $new_item != false)
				$content = object_merge($content, $new_item);
		});	
		foreach($data_stores as $data_store) {
			$item = $data_store->query(array('uuid' => $content->uuid));
			if(isset($item[0])) {
				$item = $item[0];
				$content = object_merge($content, $item);
			} else {
				foreach($data_store->getSchema()->getFields() as $field => $config) {
					$content->$field = null;
				}
			}
		}
		return $content;
	}
	
	/**
	 * Handler for the incomming query function.  
	 *
	 * @param string $event 
	 * @param string $dispatcher 
	 * @param string $values 
	 * @param string $type 
	 * @param string $data_stores 
	 * @return void
	 * @author Mike Reich
	 */
	public function queryHandler($event, $dispatcher, $values, $type, $data_stores) {
		$results = array();
		$cm = \I('ContentManager');
		$cm->dispatch($type.'Query', array($values), function($new_results) use (&$results) {
			if(count($new_results) > 0 && is_array($results))
				$results = array_merge($results, $new_results);
		});
		foreach($data_stores as $data_store) {
			$new_query = array();
			$intersect_fields = array_intersect(array_keys($data_store->getSchema()->getFields()), array_keys($values));
			if(count($intersect_fields) > 0) {
				foreach($intersect_fields as $field) {
					$new_query[$field] = $values[$field];
				}
				$r = $data_store->query($new_query);
				if($r && is_array($r))
					$results = array_merge($results, $r);
			}
			for($x = 0; $x < count($results); $x++) {
				$results[$x] = (object)$results[$x];
			}
		}
		return $results;
	}
	
	/**
	 * BaseComponent override of the metadata getInfo static method.
	 *
	 * @return void
	 * @author Mike Reich
	 */
	public static function getInfo() {
        return array(
            'name' => 'Content Manager Extender',
            'description' => 'Provides a convenient way of declaring new content types',
            'version' => '0.1',
            'dependencies' => array('ContentManager'),
			'package' => 'Content',
        );
    }

}